{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Purpose And Initial Premise","text":"<p>The purpose of this project is to see whether I could run Mikrotik's Router OS (or any custom code) on a locked-down ASA 5505. </p> <p>I originally had bought/acquired a whole bunch of Cisco equipment on EBay for CCNA studies and was going to re-sell it when I came across this article on Medium.</p> <p>As the article showed a pretty easy way of getting into the bootloader via VGA pin headers, I wondered if I could do the same with an ASA 5505 I had on hand. As I'm currently in the midst of upgrading my homelab with Mikrotik switches and came to be interested in RouterOS' capabilities, I wondered if I could re-purpose the device as a small travel firewall.</p> <p>However, when opening up the device and doing some research online, I got to learn that the older ASA models (5505 included), don't expose VGA pins and I wanted to see if I could bypass it.</p> <p>This repository documents my efforts and any relevant resources that I come across.</p>"},{"location":"attempts/bootloader_breaking_exploits/","title":"Breaking The Bootloader","text":"<p>While looking online initially to see if others had done something similar, I came across the following articles: </p> <ul> <li>Rapid7</li> <li>NCC Group</li> </ul>"},{"location":"attempts/bootloader_breaking_exploits/#modifying-asa-firmware-images-for-root-shell","title":"MODIFYING ASA FIRMWARE IMAGES FOR ROOT SHELL","text":"<p>The first article caught my eye as it showcased how easy it would be to modify an ASA OS image to boot into a root shell. According to their guide, all you had to do was load the firmware image in a hex editor, update some linux kernel parameters (it used linux?), load the firmware on the device, and power it on. In doing so, you were able to access a root shell that provided access to the system before the Lina binary was able to take over.</p> <p>However, I wasn't able to find much use for it here as I was only gaining access to the rootfs image (essentially looking at the base for a ramdisk). Busybox provided a lot of utilities for use there (and Lina was accessible for debugging) but I couldn't really find much else there. </p>"},{"location":"attempts/bootloader_breaking_exploits/#discovering-a-debug-screen","title":"DISCOVERING A DEBUG SCREEN","text":"<p>In finding that article, I was able to find the second article and pull up the NCC Group and the research they had done into the ASA Lina binary close to 10 years before. While most of it is irrelevant from the point of view of this project (they only debugged the Lina binary), I did come across a very minor comment (in the Convenience Tips section) that opened another avenue:</p> <p>While replacing a CF card that was malfunctioning, we noticed that the ASA 5505 (and likely other models as well) appears to have an 8GB size limit for CF cards. Inserting a 16GB CF card will simply cause the BIOS to fail POST. This size limit doesn\u2019t appear to be well documented and we didn\u2019t investigate further. Interestingly this drops you to an extended BIOS debug (EBDEBUG) shell (which doesn\u2019t seem to be well documented).</p> <p>In wanting to try and replicate this, I purchased a 16 GB CF card, inserted it into the ASA, and was quickly able to force the system to boot to a BIOS-level debugger: </p> <p></p> <p>A quick Google search of the prompt for the shell (called EBDEBUG) led me to the BIOS documentation that's listed in this repo.</p> <p>With reading into the documentation and utilizing OSDev.com to get an better understanding of real-mode, interrupts, and the low-memory model, I realized that the debugger provided me with alot to understand the hardware. This included the ability to execute instructions directly against it, moving across memory by adjusting the EIP register, and even with reading/writing to flash storage.</p> <p>While I've made use of the debugger over the course of this project, I've not made a lot of attempts to run custom code through it as the debugger doesn't work as a suitable bootstrapper as it's not automatic on powerup. Though, I'm still considering this for the fun of it and for the original goal of the project.</p>"},{"location":"attempts/debugging_if_exploits/","title":"Board Debugging Interface Exploitation","text":"<p>In following the attached guide here, I looked into multiple interface exploits that I could use to gain full access. These are documented below:</p>"},{"location":"attempts/debugging_if_exploits/#uart","title":"UART","text":"<p>UART (Universal Asynchronous Receiver-Transmitter) is a serial protocol/interface that's commonly found on embedded devices. I got hooked on looking for one of these interfaces when I realized that alot of embedded devices (newer ones mind you) provide a root shell through it. While I didn't think Cisco was going to provide an easy entry point (and given this device was using 20-year old hardware), I delved into it regardless.</p> <p>Originally, I tried to voltage test some of the easily-visible pinhole patterns for UART connectivity but that led me knowhere. I wasn't able to clearly identify the Vcc, TX, and RX pins as the voltage seemed to stay consistent at 3.3 volts and didn't seem to fluctuate much within one single pin on bootup. That behavior was key as a higher fluctuating boot voltage could be indicative of the system outputting lots of bootup logs.</p> <p>While I wasn't able to find much at the time, I delved further when I realized that the following shows in the ROMMON firmware startup:</p> <p></p> <p>As two serial interfaces were detected (with only one physically accessible from an external port), I started looking at other unidentified pins/pads on the board. Several hours and one bricked Raspberry PI UART adapter later (my bad), I ultimately looked at the balls on the MCU directly. This seemed to be a good entry point as I had gotten access to the chip's documentation beforehand and discovered that it documented the chip balls used for UART connectivity.</p> <p></p> <p>Note: See next section for more information on JTAG</p> <p>With that in mind, it was only a matter of discovering the orientation of the chip on the board. This was easily done by looking at the mirror image of the diagrammed chip on the back of the board (with the AMD marking right side up when looking at the front):</p> <p></p> <p>Note: See next section for more information on JTAG</p> <p>In identifying the labeled pins, I potentially had something. While I was able to pick up the primary console's connection (using a newer Raspberry PI 5 and minicom) via the GPIO8 and GPIO9 pins, the other pins seemed dead. While GPIO3 and GPIO4 were reserved for the secondary connection in the documentation, I was able to detect little-to-no voltage on those two pins. I connected to the other labeled GPIO pins to rule those out and eventually came to the conclusion that it was locked down (or disabled in firmware) and would require board modifications that I wouldn't be comfortable with.</p>"},{"location":"attempts/debugging_if_exploits/#jtag","title":"JTAG","text":"<p>While disassembling the device originally, I came across a series of pins (curiously hidden under a barcode) that I thought were originally a place where I could solder VGA pins. At the time, I was thinking this model just didn't have them like the others did. </p> <p>However, upon some Google research and the attached guide, I determined that it actually resembled a JTAG interface (see #3), an interface standard that came out in the late 80s/early 90s to simplfy board testing. While that was it's primary use, the interface also had the benefit in it provided access to all of the signals on all traces on the device's motherboard.</p> <p>The potential usage of a JTAG connector came to an end fairly quickly though when I realized that finding hardware/software with compatibility for x86 MCUs was going to be problem. This seemed to be the case as much of the embedded engineering/hardware hacking community has moved on to other architectures. </p> <p>In addition, I couldn't identify a potential pinout for the interface and I eventually discovered that only the TDO input pin wasn't connected (see diagram photo above). With that in mind, this got pushed to the back burner due to the potential costs needed for such a small hobby project.</p>"},{"location":"attempts/reverse_engineering_rommon/","title":"Reverse-Engineering ROMMON","text":"<p>When I originally ran into the NCC Group's research, I didn't think about making modifications to the firmware image myself. However, I took it as a potential option when I thought it can't be that hard? with regards to just finding the execution entrypoint.</p> <p>While I had read over how good Binwalk was for binary analysis, I didn't dig into it until I ran across this github write-up on how someone was able to use Ghidra to view the contents of a Cisco IOS image.</p> <p>In following that write-up loosely to do the same, I was able to utilize Binwalk to discover three ELF (Executable and Linkable File) formatted-regions of the firmware and pull them in for analysis. As the rest of the firmware contained a mix of the linux kernel, the rootfs image mentioned before, and either blank space or CRC/hash values, I looked to just those three components for the execution entrypoint.</p> <p>In reviewing the format of an ELF file, listed here, I was able to strike two of those files out as utilized by the linux kernel itself (for system calls) and I traced the entrypoint to virtual address 0x100000 (noted by Ghidra). Initially, I even modified a Hello World 16-bit bootloader to use that virtual address and tried to load it as an x86 ELF binary. However, it quickly got checked by ROMMON and it was labeled as an invalid image. </p> <p>While I knew from a previous attempt that a firmware image with an invalid checksum would be allowed for booting by ROMMON if it was loaded locally with a CF writer (rather than over the network), I anticipated it failing to a degree due to the vast structual differences of my custom bootloader and the firmware image.</p> <p>Currently, I'm looking to find ways to map the entirety of memory as firmware chips are at much higher addresses (via either adjusting my PowerShell memory pull script or by pulling use hardware tools). Once that's done, I'm looking into utilizing Ghidra and other debugging/analysis tools to trace how ROMMON parses the image for execution.</p>"},{"location":"blog/","title":"Logged Work","text":""},{"location":"blog/2025/05/28/initial-doc-wiki-setup/","title":"Initial Doc Wiki Setup","text":""},{"location":"blog/2025/05/28/initial-doc-wiki-setup/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Started setting up github repository for the wiki:<ul> <li>Setup general structure (by header contents on original README.md)</li> <li>Copied over all external reference files<ul> <li>Started adjusting markdown so that they can be referenced correctly (only fixed generic board documentation).</li> </ul> </li> </ul> </li> </ul>"},{"location":"blog/2025/05/28/initial-doc-wiki-setup/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <ul> <li>PORJECT: Fix the weakspots.md file so that any other repo files can be accessed correctly.</li> </ul>"},{"location":"blog/2025/05/30/uart-possibility/","title":"UART Possibility?","text":""},{"location":"blog/2025/05/30/uart-possibility/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Continued looking into the possibility of finding a UART connection. <ul> <li>Read into the possibility of using a Raspberry PI as a serial UART adapter.</li> </ul> </li> </ul>"},{"location":"blog/2025/05/30/uart-possibility/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <ul> <li>PROJECT: Configure my old Raspberry PI Model B+ as a serial UART adapter and check the unknown pins for a potential connection.</li> </ul>"},{"location":"blog/2025/05/31/identifying-uart-day-1/","title":"Identifying UART (Day 1)","text":""},{"location":"blog/2025/05/31/identifying-uart-day-1/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Re-configured my original Raspberry PI Model B+ to act as a UART serial adapter.<ul> <li>Verified that it worked by connecting the transmit/receive pins together and typing to view output with the Minicom terminal software.</li> </ul> </li> <li>Began working to identify the secondary UART connection (starting with the unknown interfaces near the JTAG connector). </li> </ul>"},{"location":"blog/2025/05/31/identifying-uart-day-1/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <ul> <li>PROJECT: Continue working to identify the secondary UART connection by checking other pads/pins.</li> </ul>"},{"location":"blog/2025/06/01/identifying-uart-day-2/","title":"Identifying UART (Day 2)","text":""},{"location":"blog/2025/06/01/identifying-uart-day-2/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Continued working to identify UART pins by voltage testing smaller pads/pins on board.<ul> <li>This was put to a stop as I accidentally fried my older Raspberry PI Model B+ by connecting the pi's UART receive   pin to a high voltage component on the ASA.</li> </ul> </li> <li>Ordered new Raspberry PI 5 to use as a replacement UART serial adapter.</li> </ul>"},{"location":"blog/2025/06/01/identifying-uart-day-2/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <ul> <li>PROJECT: Configure the Raspberry PI 5 as a serial UART adapter once it arrives. <ul> <li>Use it to potentially identify the UART pins/pads that haven't been tested yet.</li> </ul> </li> </ul>"},{"location":"blog/2025/06/03/identifying-uart-day-3/","title":"Identifying UART (Day 3)","text":""},{"location":"blog/2025/06/03/identifying-uart-day-3/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Received new power supply for Raspberry PI 5 and configured the device as a serial UART adapter.</li> <li>Utilized serial adapter and multimeter to identify UART balls on MCU.<ul> <li>This was attempted after re-reading the MCU documentation.</li> <li>We verified that the default console interface could be pulled (to see the normal bootup procedure) but not the secondary interface.</li> </ul> </li> </ul>"},{"location":"blog/2025/06/03/identifying-uart-day-3/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <ul> <li>DOC WIKI: Finish setting up new documentation (and fix an issue where PDFs or repo-local files couldn't be loaded in the browser).</li> <li>PROJECT: Look into other hardware hacking techniques for the device outside of UART/JTAG. (Potentially look into techniques to identify firmware chips and pull directly from them instead.)</li> </ul>"},{"location":"blog/2025/06/04/doc-wiki-re-organization-hardware-software-attempts/","title":"Doc Wiki Re-Organization (Hardware, Software, Attempts)","text":""},{"location":"blog/2025/06/04/doc-wiki-re-organization-hardware-software-attempts/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Added general memory layout to documentation (pulled from rooted Cisco ASA firmware bootup logs).</li> <li>Removed text-based documentation for board pins and organized the data into tables in markdown.</li> <li>Broke documentation into separate parent navigation entries for hardware/software.<ul> <li>Started doing the same with an Attempts section.</li> </ul> </li> </ul>"},{"location":"blog/2025/06/04/doc-wiki-re-organization-hardware-software-attempts/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <ul> <li>DOC WIKI: Add/organize other content from the original README file.</li> <li>PROJECT: Look into other hardware hacking techniques for the device outside of UART/JTAG.</li> </ul>"},{"location":"blog/2025/06/06/initial-wiki-finalization/","title":"Initial Wiki Finalization","text":""},{"location":"blog/2025/06/06/initial-wiki-finalization/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Added board pin diagram/photo and ROMMON interface image to interface exploits documentation page.</li> <li>Re-worked project so that all repo PDFs could be displayed appropriately in the browser.</li> <li>Created documentation pages for bootloader exploits and the reverse engineering of ROMMON.</li> </ul>"},{"location":"blog/2025/06/06/initial-wiki-finalization/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <p>Not known yet</p>"},{"location":"blog/2025/07/23/project-wrapup-for-the-time-being/","title":"Project Wrapup (For The Time Being)","text":""},{"location":"blog/2025/07/23/project-wrapup-for-the-time-being/#work-completed","title":"Work Completed","text":"<p>On this date, the following was completed:</p> <ul> <li>Uploaded all additional hardware documentation and cleaned up code repo.</li> </ul>"},{"location":"blog/2025/07/23/project-wrapup-for-the-time-being/#current-status-next-steps","title":"Current Status / Next Steps","text":"<p>Going forward, I will be doing the following:</p> <ul> <li>The project is being put on hold for now (due to a lack of interest). If I do resume it,   the next step would be to look into the CPU documentation and try to get graphical output    (as the hardware reference seems to indicate that there are pins for it).</li> </ul>"},{"location":"hardware/board/","title":"Board Reference","text":""},{"location":"hardware/board/#component-reference","title":"Component Reference","text":"<ol> <li> <p>Companion processor: AMD Geode CS35536 (Southbridge)</p> <ul> <li>Communicates with primary CPU and compact flash</li> <li>Communicates with USB</li> <li>Handles IO</li> <li>Has RTC (Real-Time Clock) - Powered by CMOS battery</li> </ul> </li> <li> <p>Main Processor: AMD Geode XL600, x86 CPU running at 500MHz</p> </li> <li> <p>JTAG?</p> </li> <li> <p>Physical IO chip for Layer1: Marvel 88ACS06 (octal PHY)</p> <ul> <li>8 IO Ports To 8 100 MB Ethernet Ports</li> </ul> </li> <li> <p>ROMMON: SST 49LF016C 2MB Flash chip</p> </li> <li> <p>ASA OS: CF (Compact Flash) Card</p> </li> <li> <p>Onboard accelerator/ASIC: </p> <ul> <li>Front (FPGA) - Handles VPN</li> <li>Back (Cavium Nitrox Lite security macro processor) - Handles Encryption</li> </ul> </li> <li> <p>NVRAM: ST Microelectronics 24CD4WP (4Kbit EEPROM)</p> </li> <li> <p>Security microcontroller for Flash: Atmel 12836RCT</p> <ul> <li>Prevents cleartext data at rest in flash</li> </ul> </li> <li> <p>PoE controller: Linear Technology LTC4259ACGW</p> </li> <li> <p>DDR RAM Module</p> </li> <li> <p>Serial Console: ADM3202 RS232 transceiver</p> </li> </ol>"},{"location":"hardware/board_if_pinouts/","title":"Board Interface Pin-Outs","text":""},{"location":"hardware/board_if_pinouts/#p1-possible-jtag","title":"P1 (Possible JTAG?)","text":"Pin # Type Measured Voltage (V) 1 Ground N/A 2 ? 3.3 3 Ground N/A 4 ? 2.2-2.3 5 Ground N/A 6 ? 3.3 7 Ground N/A 8 ? 3.3 9 Ground N/A 10 ? 3.3 11 ? 3.3 12 ? 3.05-3.1 13 ? ? 14 Ground N/A"},{"location":"hardware/board_if_pinouts/#p8","title":"P8","text":"Pin # Type Measured Voltage (V) 1 ? 3.3 2 ? 3.3 3 Ground N/A 4 ? ? 5 ? ?"},{"location":"hardware/board_if_pinouts/#p9","title":"P9","text":"Pin # Type Measured Voltage (V) 1 ? 3.3 2 ? 3.3 3 Ground N/A"},{"location":"hardware/board_if_pinouts/#rst-system-powerreboot-pins","title":"RST (System Power/Reboot Pins?)","text":"Pin # Type Measured Voltage (V) 1 ? 3.0-3.5 2 Ground N/A"},{"location":"hardware/board_if_pinouts/#j21","title":"J21","text":"Pin # Type Measured Voltage (V) 1 ? 3.3 2 ? ?"},{"location":"software/memory_layout/","title":"Memory Layout","text":""},{"location":"software/memory_layout/#ranges-provided-by-bios","title":"Ranges (Provided By BIOS)","text":"<ul> <li>BIOS-e820: 0000000000000000 - 000000000009e000 (usable)</li> <li>BIOS-e820: 000000000009e000 - 00000000000a0000 (reserved)</li> <li>BIOS-e820: 00000000000dc000 - 0000000000100000 (reserved)</li> <li>BIOS-e820: 0000000000100000 - 000000001fbe9000 (usable)</li> <li>BIOS-e820: 000000001fbe9000 - 0000000020000000 (reserved)</li> <li>BIOS-e820: 00000000fff00000 - 0000000100000000 (reserved)</li> </ul>"},{"location":"software/software_boot_process/","title":"Software (Device Boot Process)","text":"<p>In order to understand or get an idea of what was needed to start cracking the 5505, I needed to review the boot process. I've got it simplified below:</p> <p>EMBEDDED BIOS -&gt; ROMMON -&gt; CISCO ASA</p> <p>While the Cisco ASA software itself drives the firewall, it isn't the only piece in the boot process. Cisco ASA is itself an OS in the form of a .bin (binary) file that's loaded by an on-chip firmware called ROMMON. This chip is responsible for both booting the OS and providing recovery in case the ASA OS is un-authentic or corrupted. The downside with this firmware though is that it is only designed to boot Cisco-provided firmware images and we can't overwrite it as a bootloader.</p> <p>While delving into how I could find a way around ROMMON, I was able to track down some documentation regarding the BIOS in use. Specifically, it looks to be a piece of embedded software called, quite-literally, EMBEDDED SOFTWARE and it was produced by a company (General Software, Inc.) that has since been bought out. </p> <p>While the version on-board the device is much older [1.0(12)13] than the 4.1 or 4.3 documentation I found, it still pretty essential in that I'm not able to find anything else with regards to the BIOS software (or the included debugger).</p>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}